# C Plus 预处理器与 C 库

- 预处理指令：#define、#include、#ifdef、#else、#endif、#ifndef 、#if 、#elif 、#line 、#error 、#pragma 
- 关键字：_Generic、_Noreturn、_Static_assert
- 函数/ 宏： sqrt() 、atan() 、atan2() 、exit() 、atexit() 、assert() 、memcpy() 、memmove() 、va_start() 、va_arg() 、
va_copy()、va_end() 
- C 预处理器的其他功能
- 通用选择表达式
- 内联函数
- C 库概述和一些特殊用途的方便函数

---
- [C Plus 预处理器与 C 库](#c-plus-预处理器与-c-库)
	- [1. 编译源文件的第一步(翻译)](#1-编译源文件的第一步翻译)
	- [2. #define 明示常量](#2-define-明示常量)
		- [2.1 记号](#21-记号)
		- [2.2 重定义常量](#22-重定义常量)
	- [3. 在 define 中使用参数](#3-在-define-中使用参数)
		- [3.1 宏参数创建字符串 # 运算符](#31-宏参数创建字符串--运算符)

---
## 1. 编译源文件的第一步(翻译)

> 在预处理之前, 编译器会对该程序进行一下翻译处理:
  
- 首先，编译器把源代码中出现的字符映射到源字符集 (处理多字节字符与三字符序列, 字符扩展)
  
- 第二，编译器定位每个反斜杠后面跟着换行符的实例，并删除它们(换行符指通过按下 Enter 键在源代码文件中换行所生成的字符，而不是指符号表征 \n)

```c
	//把下面两个物理行（physical line）：
	printf("That's wond\
	erful!\n");
	//转换成一个逻辑行（logical line）：
	printf("That's wonderful\n!");
	//由于预处理表达式的长度必须是一个逻辑行, 一个逻辑行可以是多个物理行
```

- 第三，编译器把文本划分成预处理记号序列、空白序列和注释序列（记号是由空格、制表符或换行符分隔的项）

```c
	//编译器将用一个空格字符替换每一条注释
	int/* 这看起来并不像一个空格*/fox;
	//将变成：
	int fox;
	//而且，实现可以用一个空格替换所有的空白字符序列（不包括换行符）
```

- 最后，程序已经准备好进入预处理阶段，预处理器查找一行中以#号开始的预处理指令。

---
## 2. #define 明示常量

- #define 指令来定义明示常量（manifest constant）（也叫做符号常量）

```c
	#define SIZE 10;
	// #define  指令
	// SIZE     宏, 选定的缩写
	// 10 		替换列表或替换体
```

- 预处理器在程序中找到宏表示的实例后，就会用替换体代替该宏。从宏变成最终替换文本的过程称为宏展开（macro expansion）

```c
#include <stdio.h>
#define TWO 2
#define PX printf("X is %d.\n",x)

int main(void)
{
	int x = TWO;
	PX; // 预处理时用 "printf("X is %d.\n",x)" 替换 PX
}
```

> 宏展开过程

- 由于编译器在编译期对所有的常量表达式（只包含常量的表达式）求值，所以预处理器不会进行实际的乘法运算，这一过程在编译时进行。
  
- 预处理器不做计算，不对表达式求值，它只进行替换。

---
### 2.1 记号

- 从技术角度来看，可以把宏的替换体看作是记号（token）型字符串，而不是字符型字符串

- 由于编译器理解 C 语言的规则，所以不要求代码中用空格来分隔记号

- C 编译器可以把 2\*2 直接视为 3 个记号，因为它可以识别 2 是常量，\* 是运算符。

---
### 2.2 重定义常量

- 定义相同, 替换体发生改变

---
## 3. 在 define 中使用参数

- 在 #define 中使用参数可以创建外形和作用与函数类似的类函数宏

```c
	#define FUN(X,Y) (((X)+(Y))/2)
	// X, Y   宏参数
	//FUN()	  宏函数

	#define SQUARE(X) X*X
	//在程序中可以这样用：
	z = SQUARE(2);   // 2*2 = 4;
	Z = SQUARE(z+1); // z+1*z+1 = 4+4+1 = 9;
	// 宏函数与标准函数的区别在于, 宏仅仅是在预处理阶段将替换体替换掉宏标识, 并不参与计算
```

- 可以使用足够多的圆括号来确保宏函数正确的结合顺序

---
### 3.1 宏参数创建字符串 # 运算符

- C 允许在字符串中包含宏参数。在类函数宏的替换体中，# 号作为一个预处理运算符，可以把记号转换成字符串

- 如果 x 是一个宏形参，那么 #x 就是转换为字符串 "x" 的形参名。这个过程称为字符串化（stringizing）

```c
	#define PSQR(x) printf("The square of " #x " is %d.\n",\
	((x)*(x))) int main(void)

	int y = 5;
	PSQR(y);
	PSQR(2 + 4);
```


