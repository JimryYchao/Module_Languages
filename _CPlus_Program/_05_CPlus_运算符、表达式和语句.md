# C Plus 运算符,表达式和语句

---
- [C Plus 运算符,表达式和语句](#c-plus-运算符表达式和语句)
  - [1. 基本运算符(operator)](#1-基本运算符operator)
  - [2. 其他运算符](#2-其他运算符)
    - [2.1 sizeof 运算 与 size_t 类型](#21-sizeof-运算-与-size_t-类型)
    - [2.2 求模运算符 %](#22-求模运算符-)
    - [2.3 递增运算符 ++](#23-递增运算符-)
    - [2.4 递减运算符 --](#24-递减运算符---)
    - [2.5 递增运算优先级及注意](#25-递增运算优先级及注意)
  - [3. 表达式和语句](#3-表达式和语句)
  - [4. 类型转换](#4-类型转换)
    - [4.1 类型转换规则](#41-类型转换规则)
    - [4.2 待赋值的值与目标类型不匹配时](#42-待赋值的值与目标类型不匹配时)
    - [4.3 强制类型转换符](#43-强制类型转换符)
  - [5. 复合赋值运算符](#5-复合赋值运算符)

---
## 1. 基本运算符(operator)

> 术语

- 数据对象：用于储存值的数据存储区域统称为数据对象（data object）
- 左值：用于标识特定数据数据对象的名称或表达式（lvalue）
- 对象指的是实际的数据存储，而左值是用于标识或定位存储位置的标签。左值代表指定一个对象，引用内存中的地址。
- 右值（rvalue）指的是能赋值给可修改左值的量，且本身不是左值


```c
    // 赋值运算符 =
    int num1 = 1;   // 初始化
    num1 = 2;       // 赋值
    int num2,num3,num4;
    num2 = num3 = num4 = num1;  //C允许程序中的多重赋值: n = n1 = n2;

    // 加法运算符 +
    num2 = num3 + num4;

    // 减法运算符 -
    num2 = num2 - num3

    // 符号运算符 -,+
    num4 = -15;
    num3 = -num4;

    // 乘法运算符 *
    num1 = num2 * num3

    // 除法运算符 /
    num2 = num1 / 2
    // 整数除法结果仍未整数,小数部分被丢弃  --- 截断
    // 浮点数除法为浮点数
```

---
## 2. 其他运算符

### 2.1 sizeof 运算 与 size_t 类型
   
- sizeof运算符以字节为单位返回运算对象的大小

```c
    #include<stdint.h>

    int size = sizeof(int32_t); // 4
    int size2 = sizeof size;    // 4
```

- 【C99】%zd 转换说明: 使用 sizeof(value)/sizeof(type) 返回size_t 类型
- 编译器不支持 %zd 转换说明，用 %u 或 %lu 

- size_t 为 unsigned long long int 类型（别名）、

---
### 2.2 求模运算符 %

- 求模运算符只能用于整数运算，给出表达式的余数。
- 负数求模的结果也为负数

---
### 2.3 递增运算符 ++

- 将运算对象递增1，有两种方式出现，前缀与后缀模式
- 两种模式的区别在于递增行为发生的时间不同：
  - 前缀：num = ++a （a递增后，结果赋值给 num）
  - 后缀：num = a++ （先 a 赋值给 num，后递增）

---
### 2.4 递减运算符 --

- 将运算对象递减1，有两种方式出现，前缀与后缀模式
  - 前缀：num = --a （先减后赋值）
  - 后缀：num = a-- （先赋值后减）  

---
### 2.5 递增运算优先级及注意

- ++，--运算符的优先级高于基本运算符，低于（）运算
- 前缀模式中，先递增或递减操作数，后使用操作数
- 后缀模式中，先使用操作数，后递增或递减操作。

> 注意

- 如果一个变量出现在一个函数的多个参数中，不要对该变量使用
递增或递减运算符；
- 如果一个变量多次出现在一个表达式中，不要对该变量使用递增
或递减运算符。

---
## 3. 表达式和语句

- 表达式(expression) 由运算符和运算对象(操作数)组成
- 语句(statement) 表示程序的基本构件块
- 副作用(side effect) 时对数据对象或文件的修改
- 序列点(sequence point) 时程序执行的点，分号结束语标记了一个序列点
- 完整表达式(full expression)，就是指这个表达式不是另一个更大表达式的子表达式
- 复合语句(块)(compound statement) 是 { } 内部的一条或多条语句

---
## 4. 类型转换

- 升级（promotion）：较小类型转换成较大类型
- 降级（demotion）：把一种类型转换成更低级别的类型
- 通常，在语句和表达式中应使用类型相同的变量和常量。但是，如果使用混合类型，C会采用自动类型转换规则。

---
### 4.1 类型转换规则

- 当类型转换出现在表达式时，无论是 unsigned 还是 signed 的 char 和short 都会被自动转换成 int，如有必要 unsigned short 会被转换成 unsigned int（系统中 int 与 short 大小相同时）
- 设计两种类型的运算，两个值会被分别转换成两种类型的更高级别。
- 类型级别的顺序（降序）long double、double、float、unsigned LL、LL、unsigned L、long、unsigned int、int。
- 赋值语句中，计算的最终结果会被转换成被赋值变量的类型，其中可能会出现类型的升级或降级。
- 参数传递时，char 和 short 被转换成 int，float 被转换成 double。

---
### 4.2 待赋值的值与目标类型不匹配时

1. 目标类型是无符号整数，且待赋的值是整数时，额外的位将被忽略（目标类型是 8 位 unsigned char，待赋的值是原始值求模256）
2. 如果目标类型是一个有符号整型，且待赋的值是整数，结果因实现而异
3. 如果目标类型是一个整型，且待赋的值是浮点数，该行为是未定义的。当浮点类型被降级为整数类型时，原来的浮点值会被截断

---
### 4.3 强制类型转换符

```c
    // (type) value
    int num;
    long long num1 = 10000000000L;
    long long num2 = 10000000000L;
    num = (int)num1 + (int)num2;
```

---
## 5. 复合赋值运算符

```
  +=, -=, *=, /=, %=

  num += exp  等价于  num = num + exp
```