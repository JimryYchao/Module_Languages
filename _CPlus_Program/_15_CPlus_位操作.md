# C Plus 位操作

- 运算符：～、&、|、^、<<、>>
- &=、|=、^=、>>=、<<=
- 二进制、十进制和十六进制记数法
- 处理一个值中的位的两个 C 工具：位运算符和位字段
- 关键字：_Alignas、_Alignof

---
- [C Plus 位操作](#c-plus-位操作)
	- [1. 二进制数、位和字节](#1-二进制数位和字节)
		- [1.1 二进制整数](#11-二进制整数)
		- [1.2 有符号整数](#12-有符号整数)
		- [1.3 二进制浮点数](#13-二进制浮点数)
	- [2. 其他进制数](#2-其他进制数)
		- [2.1 八进制](#21-八进制)
		- [2.2 十六进制](#22-十六进制)
	- [3. C 按位运算符](#3-c-按位运算符)
		- [3.1 按位逻辑运算符](#31-按位逻辑运算符)
		- [3.2 掩码](#32-掩码)
		- [3.2 打开位 (设置位)](#32-打开位-设置位)
		- [3.3 关闭位 (清空位)](#33-关闭位-清空位)
		- [3.4 切换位](#34-切换位)
		- [3.5 检查位的值](#35-检查位的值)
		- [3.6 移位运算符](#36-移位运算符)
		- [3.7 按位运算案例](#37-按位运算案例)
	- [4. 位字段](#4-位字段)
		- [4.1 位字段与按位运算符](#41-位字段与按位运算符)
	- [5. 对齐特性 (C11)](#5-对齐特性-c11)
		- [5.1 _Alignof](#51-_alignof)
		- [5.2 _Alignas](#52-_alignas)
		- [5.3 对齐动态分配的内存 aligned_alloc](#53-对齐动态分配的内存-aligned_alloc)

---
## 1. 二进制数、位和字节

> 十进制与二进制之间的运算

```
	123 = 2^6 + 2^5 + 2^4 + 2^3 + 2^1 + 2^0

	123(10) = 01111011(2)  
```

---
### 1.1 二进制整数

- 通常，1 字节包含 8 位。C 语言用字节（byte）表示储存系统字符集所需的大小，所以 C 字节可能是 8 位、9 位、16 位或其他值

- 以 8 位为一个字节作为标准

```
			高阶位-----------------------低阶位
位编号 >>>>>  7   6   5   4   3   2   1   0
		    | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 |
位值   >>>>> 128  64  32  16  8   4   2   1 

  	# 该字节的值是 64 + 8 或 72
```

- 该位可以表示的范围是 00000000 ~ 11111111, 根据不同的方式解释位组合 (bit pattern)

- 通常 unsigned char 用 1 字节表示的范围是 0～255，而 signed char 用 1 字节表示的范围是 -128～+127。

---
### 1.2 有符号整数

- 二进制下如何表示有符号整数取决于硬件，而不是 C 语言

> 符号量方法

- 一种方式是将高阶位的 0 表示正数, 1 表示负数, 符号位之后的所有位表示数字，8 位能够表示的范围是 -127～+127。 但是有两个 +0 和 -0 的现象

> 二进制补码

- 另一种是二进制补码（two’s-complement）方法，是当今最常用的系统。二进制补码用 1 字节中的后 7 位表示 0～127，高阶位设置为 0。二进制补码符号判定与第一种方式相同，但区别在于如何确定负值

- 二进制补码确定负值的量: 从一个 9 位组合 1,0000,0000（256 的二进制形式）减去一个负数的位组合，结果是该负值的量, 可以表示的范围是 -128~127

```
	# 第一种方式
		1. 00000000 与 10000000 分别表示 +0 与 -0，
	   >> 能表示的范围是 11111111(-127) ~ 01111111(127)

	# 第二种方式 
		1. 对于一个负值的位组合 10000000 (无符号表示为 128)
		2. 但 10000000 有符号时表示一个负数
		3. 100000000(补码) - 10000000 = 10000000 (确定负数的值 128)
	   >> 因此这个二进制表示的数为 -128

		   100000000
		 - 	10101101				10101101 表示为十进制
		--------------		>>>>      -(2^6+2^4+2^1+2^0)
			 1010011					
```

> 二级制反码

- 第三种方式是二进制反码 (one’s-complement)，通过反转位组合中的每一位形成一个负数, 如 00000001 为 1, 则 11111110 是 -1

- 这种方法也有一个 −0：11111111。该方法能表示 -127～+127 之间的数。

---
### 1.3 二进制浮点数

- 浮点数分两部分储存：二进制小数和二进制指数

> 二进制小数

```
	# 十进制小数
	 	0.527 十进制表示为 5/10 + 2/100 + 7/1000
	
	# 在二进制小数中，使用 2 的幂作为分母，所以二进制小数 .101 表示为
		1/2 + 0/4 + 1/8
```

- 许多分数（如，1/3）不能用十进制和二进制表示法精确地表示，二进制表示法只能精确地表示多个 1/2 的幂的和。

> 浮点数表示法

- 为了在计算机中表示一个浮点数，要留出若干位（因系统而异）储存二进制分数，其他位储存指数

- 数字的实际值是由二进制小数乘以 2 的指定次幂组成,
  
- 一个浮点数乘以 4，那么二进制小数不变，其指数乘以 2，二进制分数不变。如果一份浮点数乘以一个不是 2 的幂的数，会改变二进制小数部分，如有必要，也会改变指数部分。

---
## 2. 其他进制数

- 计算机界通常使用八进制记数系统和十六进制记数系统

---
### 2.1 八进制

- 八进制（octal）是指八进制记数系统

```
	# 八进制	0451(8)
		4*8^2 + 5*8^1 + 1*8^0 = 297(10)
```

> 八进制与二进制之间的转换

```
	0 >>> 000		4 >>> 100
	1 >>> 001		5 >>> 101
	2 >>> 010		6 >>> 110
	3 >>> 011		7 >>> 111

	0173(8) >>> 0000,0111,1011(2)
```

### 2.2 十六进制

- 十六进制（hexadecimal或hex）是指十六进制记数系统 (0~9, A~F = 10~15)

```
	# 十六进制	A3F(16)
		10*16^2 + 3*16^1 + 15*16^0 = 2623(10)
```

> 十六进制和等价的二进制

```
	0 >>> 0000		8 >>> 1000
	1 >>> 0001		9 >>> 1001
	2 >>> 0010		A >>> 1010
	3 >>> 0011		B >>> 1011
	4 >>> 0100		C >>> 1100
	5 >>> 0101		D >>> 1101
	6 >>> 0110		E >>> 1110
	7 >>> 0111		F >>> 1111
```

---
## 3. C 按位运算符

### 3.1 按位逻辑运算符

- 4 个按位逻辑运算符都用于整型数据，包括 char

- 按位（bitwise）运算，这些操作都是针对每一个位进行，不影响它左右两边的位。

> 运算符

1. 按位取反【 ~ 】：一元运算符 ～ 把 1 变为 0，把 0 变为 1

```c
	~(10010101) = 
	  01101010
```

2. 按位与【 & 】：二元运算符 & 通过逐位比较两个运算对象，生成一个新值（只有 1 & 1 = 1，其他结果均为 0），0&0 = 0，1&1 = 1，0&1 = 0 

```c
	11010110 & 
	01101011 = 
	01000000

	val &= num  >>  val = val & num
```

3. 按位或【 | 】：二元运算符 |，通过逐位比较两个运算对象，生成一个新值（存在 1 时结果为 1），0|0 = 0，1|1 = 1，0|1 = 1 

```c
	10101110 |
	01001010 =
	11101110

	val |= num  >>  val = val | num
```

4. 按位异或【 ^ 】：二元运算符^逐位比较两个运算对象。对于每个位，如果两个运算对象中相应的位一个为1（但不是两个为1），结果为1，0^0 = 0，1^1 = 0，0^1 = 1

```c
	10101101 ^
	01011101 =
	11110000

	val ^= num  >>  val = val ^ num
```

---
### 3.2 掩码

- 按位与运算符常用于掩码（mask）。所谓掩码指的是一些设置为开（1）或关（0）的位组合

> 掩码操作

1. 假定符号常量 MASK 为 2（00000010）

2. flags &= MASK：表示将 flags 除 1 号位以外的所有位都设置为 0（无论 flags 的一号位是 0 或 1，其他位都会变成 0）

3. 把掩码中的 0 看作不透明，1 看作透明，表达式 flags & MASK 相当于用掩码覆盖在 flags 的位组合上，只有 MASK 为 1 的位才可见

```c
	flags &= MASK >>>>>>> 将非 1 位清 0

	MASK  >>>  00000010  >>>  ______1_
	按位与		   &
	flags >>>  10010110  >>>  10010110
				 掩码
	flags >>>  ______1_  >>>  00000010
```

> 按位与的常用法

```c
	ch &= 0xff;		// 或 ch &= 0377
	//即
	ch &= 11111111;
```

---
### 3.2 打开位 (设置位)

- 有时，需要打开一个值中的特定位，同时保持其他位不变

```c
	flags |= MASK >>>>>>> 将 1 位设置为 1

	MASK  >>>  00000010  >>>  ______1_
	按位或	       |
	flags >>>  10101001  >>>  10101001
	            打开位
	flags >>>  ______1_  >>>  10101011
```

---
### 3.3 关闭位 (清空位)

- 和打开特定的位类似，有时也需要在不影响其他位的情况下关闭指定的位

```c
	flags &= ~MASK >>>>>>> 将 1 位关闭为 0

	MASK  >>>  10110110 	
	按位取反       ~
	MASK  >>>  01001001  >>>  _1__1__1
	按位与         &
	flags >>>  00001111  >>>  00001111
	            关闭位
	flags >>>  0_00_00_  >>>  00001001  
```

---
### 3.4 切换位

- 切换位指的是打开已关闭的位，或关闭已打开的位。可以使用按位异或运算符（^）切换位

```c
	flags ^= MASK >>>>>>> 将指定的位取反，0➡1，1➡0

	MASK  >>>  00110010  >>>  __11__1_
	按位异或	   ^
	flags >>>  10101001  >>>  10101001
	            切换位
	flags >>>  __01__1_  >>>  10011011
```

---
### 3.5 检查位的值

- 有时，需要检查某位的值。例如，flags 中 1 号位是否被设置为 1？

- 检查指定位时需要将其他无关的位掩码（flags & MASK）

```c
	if((flags & MASK) == MASK)
	// flags 指定位的值不会被修改，与 MASK 对比指定位是否相等，可以获取到当前位的值
```

---
### 3.6 移位运算符

- 移位运算符向左或向右移动位

> 左移 <<

- 左移运算符（<<）将其左侧运算对象每一位的值向左移动其右侧运算对象指定的位数，左侧运算对象移出左末端位的值丢失，用 0 填充空出的位置

```c
	(10110100) << 2
  10 110100__          高位丢失，低位 0 补齐
	 11010000

>>>> 10110100 << 2 = 11010000
>>>> val <<= 2  >>>>  val = val << 2	 
```

> 右移 >>

- 右移运算符（>>）将其左侧运算对象每一位的值向右移动其右侧运算对象指定的位数。左侧运算对象移出右末端位的值丢失

- 对于无符号数，用 0 补齐高位空出的地方

- 对于有符号数，其结果取决于机器。空出的位置可用 0 填充，或者用符号位（即，最左端的位）的副本填充

```c
	// 有符号值表示
	(10001010) >> 2 	
	(00100010) 		// 在某些系统中的结果值, 0 填充
	(10001010) >> 2 
	(11100010) 		// 在另一些系统上的结果值, 符号位 1 填充
	// 无符号值表示
	(10001010) >> 2 
	(00100010) 		// 所有系统都得到该结果值
```

> 移位运算符用法

- 移位运算符针对 2 的幂提供快速有效的乘法和除法：

```c
	number << n    // number 乘以 2 的 n 次幂
	number >> n    // 如果 number 为非负，则用number除以 2 的 n 次幂
```

---
### 3.7 按位运算案例

> 使用位操作显示二进制

- 读取用户从键盘输入的整数，将该整数和一个字符串地址传递给 itobs() 函数

- itobs 表示 interger to binary string，即整数转换成二进制字符串

- 该函数使用移位运算符计算出正确的 1 和 0 的组合，并将其放入字符串中

```c
#include <stdio.h>
#include <limits.h> // 提供 CHAR_BIT 的定义，CHAR_BIT 表示每字节的位数
char *itobs(int, char *);
void show_bstr(const char *);
int main(void)
{
	char bin_str[CHAR_BIT * sizeof(int) + 1]; // int32 * 8 + 1 >> '\0'
	int number;
	puts("Enter integers and see them in binary.");
	puts("Non-numeric input terminates program.");
	// 扫描输入的数字
	while (scanf("%d", &number) == 1)
	{
		itobs(number, bin_str); // 将数字转换成
		printf("%d is ", number);
		show_bstr(bin_str);
		putchar('\n');
	}
	puts("Bye!");
	return 0;
}
char *itobs(int n, char *ps)
{
	int i;
	const static int size = CHAR_BIT * sizeof(int);
	// 二进制下依次右移, 高位向低位移动
	for (i = size - 1; i >= 0; i--, n >>= 1) 
	// 掩码操作, 逐最低位获取当前最低位的值并存储在字符组中
		ps[i] = (01 & n) + '0'; //数字转换数字字符 , 该数字 + '0'
	// 末尾添加 \0 转换字符串
	ps[size] = '\0';
	return ps;
}
/*4位一组显示二进制字符串 */
void show_bstr(const char *str)
{
	int i = 0;
	while (str[i]) /* 不是一个空字符 */
	{
		putchar(str[i]);
		if (++i % 4 == 0 && str[i])
			putchar(' ');
	}
}
```

---
## 4. 位字段

- 操控位的第 2 种方法是位字段（bit field）。位字段是一个 signed int 或 unsigned int 类型变量中的一组相邻的位（C99 和 C11 新增了 _Bool 类型的位字段）

- 位字段通过一个结构声明来建立，该结构声明为每个字段提供标签，并确定该字段的宽度

> 建立一个 4 个 1 位的字段

```c
	struct{
		unsigned int autfd:1;
		unsigned int bldfc:1;
		unsigned int undln:1;
		unsigned int itals:1;
	}prnt;

	// prnt 包含 4 个 1 位的字段
	// 由于每个字段恰好为 1 位，所以只能为其赋值 1 或 0
	prnt.itals = 0;
	prnt.undln = 1;

	sizeof(prnt);  // 4 B = 32 bit
	// 变量 prnt 被储存在 int 大小的内存单元中, 该结构只使用了其中的 4 位
```

- sizeof 不能操作 prnt.autfd (位域)

- 带有位字段的结构提供一种记录设置的方便途径, 位字段的储存顺序自低阶到高阶方向

- 许多设置就是简单的二选一。例如，开或关、真或假。如果只需要使用 1 位，就不需要使用整个变量。内含位字段的结
构允许在一个存储单元中储存多个设置。

> 设置有多个选择，需要多位来表示

```c
	// 创建了两个 2 位的字段和一个 8 位的字段
	struct {
		unsigned int code1 : 2;
		unsigned int code2 : 2;
		unsigned int code3 : 8;
	} prcode;

```

- 要确保所赋的值不超出字段可容纳的范围

- 声明的总位数超过一个 unsigned int 的大小时, 会溢出到下一个 unsigned int 类型的存储位置

- 一个字段不允许跨越两个 unsigned int 之间的边界, 编译器会自动移动跨界的字段, 从而保持 unsigned int 之间的边界对齐

- 发生跨越移位时, 上一个 unsigned int 中会留下一个未命名的 "洞", 可以用未命名的字段宽度 "填充" 未命名的 "洞"

> 使用一个宽度为 0 的未命名字段迫使下一个字段与下一个整数对齐

```c
	struct {
		unsigned int field1 : 1 ;
		unsigned int : 2 ;
		unsigned int field2 : 1 ;
		unsigned int : 0 ;
		unsigned int field3 : 1 ;
	} stuff;

	// 在 stuff.field1 和 stuff.field2 之间，有一个 2 位的空隙
	// stuff.field3 将储存在下一个 unsigned int 中

	sizeof(stuff);  // 8 
```

---
### 4.1 位字段与按位运算符

- 在同类型的编程问题中，位字段和按位运算符是两种可替换的方法，用哪种方法都可以

> 可以通过一个联合把结构方法和位方法放在一起

```c
	struct box
	{
		unsigned int n1 : 8;
		unsigned int n2 : 8;
		unsigned int n3 : 8;
		unsigned int n4 : 8;
	};
	union 
	{
		struct box Switch;
		unsigned int _Switch;
	} BOX;

	// 无论是 BOX.Switch 还是 BOX._Switch, 它们的地址都指向联合类型 BOX

```

> 结构中位字段在位域中的分布

```c
	// 1. 直接赋值首元素(默认) , 使用未赋值的 _Switch										
	union BOX box = {15, 16, 22, 44};		  								   
	printf("%u\n", box._Switch);	//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>//	
	printf("%u\n", box.Switch.n1);            								   // 等
	printf("%u\n", box.Switch.n2);            								   //
	printf("%u\n", box.Switch.n3);            								   // 于
	printf("%u\n", box.Switch.n4);            								   //
	printf("%p  %p\n", &(box.Switch), &(box._Switch));                          //
	printf("%u\n%u\n", +0b00001111000100000001011000101100	 //>> 252712492    //
	// 从高到低 15(00001111),16(00010000),22(00010110),44(00101100)				//	
					 , +0b00101100000101100001000000001111); //>> 739643407  <<<<
	// 从低到高	44(00101100),22(00010110),16(00010000),15(00001111)
	// 因此在位域中声明的位字段自上向下顺序, 依次从低位开始赋值占位

	/*
		739643407			>>> box._Switch
		15					>>> box.Switch.n1
		16					>>> box.Switch.n2
		22					>>> box.Switch.n3
		44					>>> box.Switch.n4
		0061FF1C  0061FF1C	>>> &(box.Switch), &(box._Switch)
		252712492			>>> 从高到低分布(15,16,22,44)
		739643407			>>> 从低到高分布(44,22,16,15)
	*/
```

> 联合中的元素存储方式与地址

```c
 	//赋值 _Switch, 直接访问 Switch 的位字段值
	union BOX box1 = {._Switch = 739643407u}; 
	printf("%u\n", box1._Switch);
	printf("%u\n", box1.Switch.n1);
	printf("%u\n", box1.Switch.n2);
	printf("%u\n", box1.Switch.n3);
	printf("%u\n", box1.Switch.n4);
	printf("Union BOX address:   %p\n"
		   "BOX.Switch address:  %p\n"
		   "BOX._Switch address: %p\n", 
		   &box1, &(box1.Switch), &(box1._Switch));	 
	// 联合中的变量的地址都是联合变量本身的地址

	/*
		Union BOX address:   0061FF18
		BOX.Switch address:  0061FF18
		BOX._Switch address: 0061FF18
	*/
```

> 联合变量在内存中的位数据与其代表的元素变量的关系

```c
	union {
		struct BOX st_view;
		unsigned int us_view;
	} box;

	// 把 box 看作一个整数 us_view
	15 >> |0|1|0|0|0|0|1|0|1|0|1|0|1|1|0|1| << 0
	// 把 box 看作一个结构 st_view
	15 >> |0|1|0|0|0|0|1|0|1|0|1|0|1|1|0|1| << 0
	       |     | |          |          |
  num_1----*     | |          |          |
  switch_1-------* |          |          |
  num_2------------*          |          |
  vid_1-----------------------*			 |
  is_Open--------------------------------*
```

> 按位视图与位字段视图

- 位字段视图和按位视图的区别是，按位视图需要位置信息。

---
## 5. 对齐特性 (C11)

- C11 的对齐特性比用位填充字节更自然，它们还代表了 C 在处理硬件相关问题上的能力

- 对齐指的是如何安排对象在内存中的位置

- 为了效率最大化，系统可能要把一个 double 类型的值储存在 4 字节内存地址上，但却允许把 char 储存在任意地址

---
### 5.1 _Alignof

- _Alignof(或 alignof) 运算符给出一个类型的对齐要求，在关键字 _Alignof 后面的圆括号中写上类型名即可

```c
	size_t d_align = _Alignof(float);	// 4 
	// C++
	size_t LL_align = alignof(long long int);  // 8
```

- 一个 float 对象的对齐要求是 4, 一个 LL 对象的对齐要求是 8

- 一般而言，对齐值都应该是2的非负整数次幂。较大的对齐值被称为 stricter 或 stronger，较小的对齐值被称为 weaker。

---
### 5.2 _Alignas 

- 可以使用 _Alignas(或 alignas) 说明符指定一个变量或类型的对齐值, 不应该要求该值小于基本对齐值

```c
	_Alignas(double) char c1;  // char 的对齐要求为 1
	alignaws(8) char c2;
	或 char alignaws(8) c2;
```

> 对齐案例

```c
#include <stdio.h>


int main(void)
{
	double dx;
	char ca;
	char cx;
	double dz;
	char cb;
	char alignas(double) cz;		// 要求 char cz 类型采用 double 对齐要求
	printf("char alignment: %zd\n", alignof(char));
	printf("double alignment: %zd\n", alignof(double));
	printf("&dx: %p\n", &dx);
	printf("&ca: %p\n", &ca);
	printf("&cx: %p\n", &cx);
	printf("&dz: %p\n", &dz);
	printf("&cb: %p\n", &cb);
	printf("&cz: %p\n", &cz);
	return 0;
}
/*
	char alignment: 1
	double alignment: 8
	&dx: 004FF918
	&ca: 004FF90F
	&cx: 004FF903
	&dz: 004FF8F0
	&cb: 004FF8E7
	&cz: 004FF8D0
*/
```

- 在系统中, double 的对齐值是 8，这意味着地址的类型对齐可以被 8 整除。
  
- 以 0 或 8 结尾的十六进制地址可被 8 整除。这就是地址常用两个 double 类型的变量和 char 类型的变量 cz

- 在程序中包含 stdalign.h 头文件后， 就可以把 alignas 和 alignof 分别作为 _Alignas 和 _Alignof 的别名

---
### 5.3 对齐动态分配的内存 aligned_alloc

- C11 在 stdlib.h 库还添加了一个新的内存分配函数，用于对齐动态分配的内存

```c
	void *aligned_alloc(size_t alignment, size_t size);
	alignment   >>>>   代表指定的对齐
	size		>>>>   所需的字节数, 是 alignment 的倍数
```

- 要使用 free() 函数释放之前分配的内存。

---