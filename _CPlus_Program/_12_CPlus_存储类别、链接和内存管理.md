# C PLus  存储类别\链接与内存管理

- 关键字：auto、extern、static、register、const、volatile、restricted、_Thread_local、_Atomic 
- 函数：rand()、srand()、time()、malloc()、calloc()、free()
- 变量的作用域（可见的范围）和生命期

---
- [C PLus  存储类别\链接与内存管理](#c-plus--存储类别链接与内存管理)
  - [1. 存储类别](#1-存储类别)
    - [1.1 作用域 scope](#11-作用域-scope)
    - [1.2 链接](#12-链接)
    - [1.3 存储期](#13-存储期)
    - [1.4 自动变量](#14-自动变量)
    - [1.5 寄存器变量](#15-寄存器变量)
    - [1.6 块作用域的静态变量](#16-块作用域的静态变量)
    - [1.7 外部链接的静态变量](#17-外部链接的静态变量)
    - [1.8 内部链接的静态变量](#18-内部链接的静态变量)
    - [1.9 多文件](#19-多文件)
    - [1.10 存储类别说明符](#110-存储类别说明符)
    - [1.11 存储类别与函数](#111-存储类别与函数)
  - [2. 随机数函数和静态变量](#2-随机数函数和静态变量)
    - [2.1 掷骰子](#21-掷骰子)

---
## 1. 存储类别

> 对象 object

- 数据都储存在内存：从硬件方面来看，被储存的每个值都占用一定的物理内存，C 语言把这样的一块内存称为对象（object）（面向对象编程中的对象表示为类对象）。

- 对象可以储存一个或多个值。一个对象可能并未储存实际的值，但是它在储存适当的值时一定具有相应的大小

- 标识符 entity 即是软件（即 C 程序）指定硬件内存中的对象的方式，标识符可以用来指定（designate）特定对象的内容

- 在 C 语言中，变量名不是指定对象的唯一途径，例如指针结构与数组

> 左值 lvalue

- 指定对象的表达式被称为左值

```c
	int num = 10;               // 可修改左值
	const int num2 = 11;        // 不可修改左值
	char str[] = "Hello";
	const char* ptr = str;     // ptr 可修改左值, *ptr 不可修改左值
	ptr = "World";
	char* const ptr2 = str;    // ptr2 不可修改左值 *ptr2 可修改
	ptr2[0] = 'h';
    const char* const ptr3 = str;  // ptr3 与 *ptr3 均是不可修改左值
```

> 存储期  storage duration

- 存储期是指对象在内存中保留了多长时间。

- 标识符用于访问对象，可以用作用域（scope）和链接（linkage）描述标识符，标识符的作用域和链接表明了程序的哪些部分可以使用它

- 对象可存在于程序的执行期，也可以仅存在于它所在函数的执行期

- 对于并发编程，对象可以在特定线程的执行期存在。
  
- 可以通过函数调用的方式显式分配和释放内存。

---
### 1.1 作用域 scope

- 作用域描述程序中可访问标识符的区域，作用域可以是块作用域，函数作用域、函数原型作用域、文件作用域

- 块作用域（block scope）块作用域变量的可见范围是从定义处到包含该定义的块的末尾（块是用一对花括号括起来的代码区域）

- 函数作用域（function scope）仅用于 goto 语句的标签：一个标签首次出现在函数的内层块中，它的作用域也延伸至整个函数

- 函数原型作用域（function prototype scope）用于函数原型中的形参名（变量名），编译器在处理函数原型中的形参时只关心它的类型，而形参名（如果有的话）通常无关紧要，只有在变长数组中，形参名才有用

- 变量的定义在函数的外面，具有文件作用域（file scope），具有文件作用域的变量，从它的定义处到该定义所在文件的末尾均可见（全局变量 global variable）

```c
#include <stdio.h>

int Number = 10; // 文件作用域/全局变量

void Function(int max, char *arr[max]); // 函数原型作用域

int main(void)
{ // 块作用域
    if (Number == 10)
    { // 块作用域
        Function(Number, arr[Number]);
    }
}
void Function(int max, char *arr[max])
{
label:
    printf("%d", max); // 函数作用域

    if (arr[0] == NULL)
    {
        goto label;
    }
}
```

> 翻译单元与文件

- 通常在源代码（.c 扩展名）中包含一个或多个头文件（.h 扩展名）

- 头文件会依次包含其他头文件，所以会包含多个单独的物理文件
 
- C 预处理实际上是用包含的头文件内容替换 #include 指令，编译器源代码文件和所有的头文件都看成是一个包含信息的单独文件。这个文件被称为翻译单元（translation unit）。

- 描述一个具有文件作用域的变量时，它的实际可见范围是整个翻译单元

---
### 1.2 链接

- C 变量有 3 中链接属性：外部链接、内部链接、无链接

- 局部变量都是无链接变量，仅包含在当前作用域私有

- 具有文件作用域的变量可以是外部或内部链接，外部可在多文件程序中使用，内部仅只能在一个翻译单元中使用

> 内部与外部链接

- C 标准用 “内部链接的文件作用域” 描述仅限于一个翻译单元（即一个源代码文件和它所包含的头文件）的作用域，用 “外部链接的文件作用域” 描述可延伸至其他翻译单元的作用域

```c
int giants = 5;         // 外部链接的文件作用域
static int size = 10;   // 内部链接的文件作用域
```

---
### 1.3 存储期

* 作用域和链接描述了标识符的可见性。存储期描述了通过这些标识符访问的对象的生存期
  - 静态存储期：在程序的执行期间一直存在（文件作用域变量具有静态存储期，static 表示变量的内部链接属性）
  - 线程存储期：用于并发程序设计，程序执行可被分为多个线程（线程存储期的对象，从被声明时到线程结束一直存在，关键字 _Thread_local 声明一个对象时，每个线程都获得该变量的私有备份）
  - 自动存储期：块作用域的变量通常都具有自动存储期（进入块时，为这些变量分配内存；离开块区域时，这些局部变量会被释放，static 表示块变量拥有静态存储期，从程序被载入到程序结束期间都存在。其他函数可以通过该存储区的地址间接访问该对象）
  - 动态分配存储期

> 5 种存储类别(不包括并发程序设计)

|**存储类别**|**存储期**|**作用域**|**链接**|**声明方式**|
|:----|:----|:----|:----|:----|
|自动|自动|块|无|块内|
|寄存器|自动|块|无|块内, register 声明|
|静态外部链接|静态|文件|外部|所有函数外|
|静态内部链接|静态|文件|内部|所有函数外, static 声明|
|静态无链接|静态|块|无|块内, static 声明|

---
### 1.4 自动变量

- 属于自动存储类别的变量具有自动存储期、块作用域且无链接

- 显式使用 auto：表明有意覆盖一个外部变量定义，或者强调不要把该变量改为其他存储类别

- 关键字 auto 是存储类别说明符（storage-class specifier）。（在 C++ 用法不同）

- 内存与外层有相同的变量名，在内部变量会覆盖外层定义，离开内层之后，恢复外层同名定义

- 自动变量不会初始化, 变量的值可能是之前占用分配给该变量空间中的任意值因此声明后需要初始化, 才能确保使用的程序的正确性

```c
int num = 1;
int main(void){
    auto int num = 2;   // 显式覆盖一个外部定义
}
```

> 举例

```c
int main()
{
	int x = 30;			// 原始的 x
	printf("x in outer block: %d at %p\n", x, &x);
	{
		int x = 77;		// 新的 x，隐藏了原始的 x
		printf("x in inner block: %d at %p\n", x,&x);
	}
	printf("x in outer block: %d at %p\n", x, &x);
	while (x++ < 33)	// 原始的 x, 每次循环使用的都是原始 x
	{
		int x = 100;	// 新的 x，隐藏了原始的 x
		x++;
		printf("x in while loop: %d at %p\n", x,
			&x);
	}
	printf("x in outer block: %d at %p\n", x, &x);
	return 0;
}
/*
	x in outer block: 30 at 0093FD00
	x in inner block: 77 at 0093FCF4
	x in outer block: 30 at 0093FD00
	x in while loop: 101 at 0093FCE8
	x in while loop: 101 at 0093FCE8
	x in while loop: 101 at 0093FCE8
	x in outer block: 34 at 0093FD00
*/
```

---
### 1.5 寄存器变量

- 变量通常储存在计算机内存中, 寄存器变量储存在 CPU 的寄存器中, 访问速度要比内存中的变量更快

- 寄存器变量无法获取到值的地址, 和自动变量一样, 寄存器变量是块作用域、无链接、自动存储期

- 使用 register 声明寄存器变量，类似于向编译器发起请求，根据寄存器或最快可用内存的数量来衡量存储请求，被忽略时就会编程普通变量
  
- 寄存器变量储存在寄存器而非内存中，所以无法获取寄存器变量的地址，即使成为普通变量也不可以使用地址运算符

- 可声明为register的数据类型有限

```c
int main(void){
    register int num = 1;       //  指定该变量储存在 CPU 寄存器中 
}
void Fun(register int num);     // 指定形参储存方式
```

---
### 1.6 块作用域的静态变量

- 静态变量（static variable）表示该变量在内存中的位置不变, 值可以发生改变

- 文件作用域变量均具有静态变量的特性, 块静态变量 (也叫内部静态存储类别) 同样具有 static 属性, 计算机在多次函数调用之间会记录它们的值

```c
void Function(void); // 函数原型
int main(void)
{
    for (size_t i = 0; i < 3; i++)
        Function();
}

void Function(void)
{
    static int recoder = 0;
    recoder++;
    printf("%d    %p\n", recoder, &recoder);
}
/*
    1    00407020
    2    00407020
    3    00407020
*/
```

---
### 1.7 外部链接的静态变量

- 外部链接的静态变量具有文件作用域、外部链接和静态存储期。也叫外部存储类别

- 变量的定义声明在函数的外部，函数中使用外部变量，可以在函数中 extern 再次声明（可选），文件域中使用另一个源代码文件的外部变量，必须在该文件中 extern 声明该变量

```c
extern char* HELLO; // 外部
extern char* WORLD; // 外部
int num = 1;
char Str[10];

int main(void)
{
    extern int num;     // 可选
    extern char Str[];  // 可选, 大小不需要再次声明   
}
```

> 外部变量初始化

- 外部变量声明时会被自动初始化为 0, 因此可以对外部变量采用显式初始化或只做声明 (内部变量需要初始化之后才可正确调用)

- 初始化外部变量只能使用常量表达式

> 外部名称

- C99 和 C11 标准都要求编译器识别局部标识符的前 63 个字符和外部标识符的前 31 个字符

> 声明与定义

```c
    int tern = 1;           // 定义式声明
    main(){
        extern int tern;    // 使用别处定义, 即引用式声明
    } 
```

---
###  1.8 内部链接的静态变量

- 内部静态变量存储类别的变量具有静态存储期、文件作用域和内部链接

- static 修饰外部变量, 表示该变量只能用于同一个文件中的函数

---
### 1.9 多文件

- 只有当程序由多个翻译单元组成时，才体现区别内部链接和外部链接的重要性

- 复杂的 C 程序通常由多个单独的源代码文件组成，C 通过在一个文件中进行定义式声明，然后在其他文件中进行引用式声明来实现共享。

- 调用其他文件的外部变量，要使用 extern 关键字

---
### 1.10 存储类别说明符

- auto 表明变量是自动存储期，只能用于块作用域的变量声明中

- register 用于块作用域的变量，它把变量归为寄存器存储类别，请求最快速度访问该变

- static 创建的对象具有静态存储期，载入程序时创建对象，当程序结束时对象消失。该变量仅作用于所用于当前作用域或嵌套作用域

- extern 表明声明的变量定义在别处。包含 extern 的声明具有文件作用域，则引用的变量必须具有外部链接

- _Thread_local 线程存储期，可以与 static 与 extern 一起使用吗，表明变量在并发线程中为各个线程私有

- typedef 关键字与任何内存存储无关，也不能用多个存储类别说明符作为 typedef 的一部分

---
### 1.11 存储类别与函数

- 函数存在存储类别，可以是外部函数（默认）或静态函数，C99 新增内联函数

```c
    double Func(void);      // 默认外部函数
    static int func(void);  // 静态函数, 内部存储期
    extern double delta(void);  // 引用外部文件的外部函数
```

---
## 2. 随机数函数和静态变量

- 随机数函数: ANSI C 提供了 rand() 函数生成随机数(伪随机数生成器), 每次生成的随机数需要一个特定的种子, 该函数使用该种子生成新的数, 这个数又成为了新的种子......方案需要一个静态变量作为种子迭代

> 可移植伪随机数函数 rand0: 

```c
static unsigned long int next = 1; /* 种子 */
unsigned int rand0(void)
{
    /* 生成伪随机数的魔术公式 */
    next = next * 1103515245 + 12345;
    return (unsigned int) (next / 65536) % 32768;
}
```

- 函数是用于返回一个0～32767之间的值

- 但每次重新启动返回的结果顺序都相同, 源于每次程序启动的起始种子总是 1

> 设置种子刷新机制

```c
static unsigned long int next = 1; /* 种子 */
int rand1(void)
{
    /*生成伪随机数的魔术公式*/
    next = next * 1103515245 + 12345;
    return (unsigned int) (next / 65536) % 32768;
}
void srand1(unsigned int seed)  // 外部调用函数重置随机数种子
{
    next = seed;
}
``` 

- 可以使用 C 访问一些可变的量(时钟系统), 使用 time() 函数返回系统时间 time_t, 和系统有关

- srand1((unsigned int) time(0)), time(ptr) 一般接受的参数是一个 time_t 类型的指针, 时间值存储在该地址上, 传入空指针只能通过返回值获取

---
### 2.1 掷骰子

- 