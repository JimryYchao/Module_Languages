# 字符输入与输出、输入验证

- 输入、输出以及缓冲输入和无缓冲输入的区别
- 重定向把程序和文件相连接

---
- [字符输入与输出、输入验证](#字符输入与输出输入验证)
  - [1. 单字符I/O getchar 与 putchar](#1-单字符io-getchar-与-putchar)
  - [2. 字符函数 (ctype.h)](#2-字符函数-ctypeh)
    - [2.1 字符测试函数](#21-字符测试函数)
    - [2.2 字符映射函数](#22-字符映射函数)
  - [3. 缓冲输入与缓冲区](#3-缓冲输入与缓冲区)
    - [3.1 缓冲类别](#31-缓冲类别)
    - [3.2 有无缓冲输入](#32-有无缓冲输入)
  - [4. C 语言处理文件的方式](#4-c-语言处理文件的方式)
    - [4.1 文件、流和键盘输入](#41-文件流和键盘输入)
    - [4.2  文件结尾](#42--文件结尾)
  - [5. 重定向和文件](#5-重定向和文件)
    - [5.1 UNIX, Linux 和 DOS 重定向](#51-unix-linux-和-dos-重定向)
    - [5.2 重定向运算符的使用原则](#52-重定向运算符的使用原则)

---
## 1. 单字符I/O getchar 与 putchar

- 通用的标准 I/O 函数，用这些函数编写的可移植程序很容易从一个系统移植到另一个系统

- getchar() 和 putchar() 每次只处理一个字符。这是绝大多数文本（即，普通文字）处理程序所用的核心方法

> 重复输入案例

- 该程序获取从键盘输入的字符，并把这些字符发送到屏幕上。程序使用 while 循环，当读到 # 字符时停止

```c
#include <stdio.h>
int main(void)
{
    char ch;
    while ((ch = getchar()) != '#')
    putchar(ch);
    return 0;
}
// input: Hello, there. I would[enter]
// output: Hello, there. I would
```

---
## 2. 字符函数 (ctype.h)

### 2.1 字符测试函数

```c
    isalnum()       字母或数字
    isalpha()       字母
    isblank()       标准空白字符,空格,水平制表符,换行符或任何本地化指定空白字符
    iscntrl()       控制字符
    isdigit()       数字
    isgraph()       除空格之外的任意可打印字符
    islower()       小写字母
    isprint()       可打印字符
    ispunct()       标点符号,除空格或数字字母之外的任何可打印字符
    isspace()       空白字符
    isupper()       大写字母
    isxdigit()      十六进制数字符
```

---
### 2.2 字符映射函数

```c
    tolower()       参数是大写字符,函数返回小写字符
    toupper()       参数是小写字符,函数返回大写字符
```

---
## 3. 缓冲输入与缓冲区

- 回显用户输入的字符后立即重复打印该字符是属于无缓冲（或直接）输入，即正在等待的程序可立即使用输入的字符

```
HHeelllloo,, tthheerree..II wwoouulldd[enter]
lliikkee aa #
```

- 大部分系统在用户按下 Enter 键之前不会重复打印刚输入的字符, 这种输入形式属于缓冲输入

- 用户输入的字符被收集并储存在一个被称为缓冲区（buffer）的临时存储区, 按下 Enter 键后，程序才可使用用户输入的字符

```
                     无缓冲输入           
    type HI!    ——————————————————>    HI! (程序可立即使用该内容)

                      缓冲输入
    type HI!    | H | I | ! |  |(缓冲区)        HI!
        |    >>>>>>    |   |     >>>>>>>>>      |
        |______________|   |____________________|
        输入字符送入缓冲区    程序可使用缓冲区的内容
```

---
### 3.1 缓冲类别

* 缓冲分为两类: 完全缓冲 I/O 和行缓冲 I/O
  - 完全缓冲输入是指当缓冲区被填满时才刷新缓冲区(内容被发送至目的地), 一般出现在文件输入中, 缓冲的大小常见是 512 字节和 4096 字节
  - 行缓冲 I/O 是指在出现换行符时刷新缓冲区, 键盘输入通常是行缓冲输入, 在 Enter 键之后刷新

---
### 3.2 有无缓冲输入

- 许多 IBM PC 兼容机的编译器都为支持无缓冲输入提供一系列特殊的函数，其原型都在 conio.h 头文件中

- 包括用于回显无缓冲输入的 getche() 函数和用于无回显无缓冲输入的 getch() 函数(回显输入意味着用户输入的字符直接显示在屏幕上)

- UNIX 系统中采用另一种方式控制缓冲, 非 C 标准: 使用 ioctl() 函数指定待输入的类型, 然后用 getchar() 执行相应的操作

- 在 ANSI C 中,用 setbuf() 和 setvbuf() 函数控制缓冲, 可能受限于一些系统的内部设置而无法作用

- ANSI没有提供调用无缓冲输入的标准方式，这意味着是否能进行无缓冲输入取决于计算机系统

---
## 4. C 语言处理文件的方式

### 4.1 文件、流和键盘输入

- 文件(file) 是存储器中储存信息的区域, 一般地, 文件都保存在某种永久存储器中

- C 程序处理文件时, 由于系统的不同, 调取底层 I/O 使用主机操作系统的基本文件工具直接处理文件的方式也不同

- C 也可以通过标准 I/O 包 (standard I/O package) 来处理文件, 这涉及创建用于处理文件的标准模型和一套标准 I/O 函数。

- 从概念上看， C 程序处理的是流而不是直接处理文件

- 流 (stream) 是一个实际输入或输出映射的理想化数据流, 这意味着不同属性和不同种类的输入，由属性更统一的流来表示。于是，打开文件的过程就是把流与文件相关联，而且读写都通过流来完成。

> 键盘输入

- C 把输入和输出设备视为存储设备上的普通文件，尤其是把键盘和显示设备视为每个 C 程序自动打开的文件。

- stdin 流表示键盘输入，stdout流表示屏幕输出。

- getchar()、putchar()、printf() 和 scanf() 函数都是标准 I/O 包的成员，处理这两个流。

- 程序读文件时要能检测文件的末尾才知道应在何处停止, 因此，C 的输入函数内置了文件结尾检测器

- 既然可以把键盘输入视为文件，那么也应该能使用文件结尾检测器结束键盘输入

---
### 4.2  文件结尾

> 计算机操作系统要以某种方式判断文件的开始和结束

- 检测文件结尾的一种方法是，在文件末尾放一个特殊的字符标记文件结尾。CP/M、IBM-DOS 和 MS-DOS 的文本文件曾经用过这种方法

- 现在这些操作系统可以使用内嵌的 Ctrl+Z 字符来标记文件结尾，也有一些其他的选择。

```
    原文:
        Ishphat the robot
        slid open the hatch
        and shouted his challenge.

    文件中:
        Ishphat the robot\n slid open the hatch\n and shouted his challenge.\n^Z

    # ^Z 带文件结尾标记的文件
```

> 操作系统使用的另一种方法是储存文件大小的信息

- 如果文件有 3000 字节，程序在读到 3000 字节时便达到文件的末尾。MS-DOS 及
其相关系统使用这种方法处理二进制文件，因为用这种方法可以在文
件中储存所有的字符，包括Ctrl+Z。

- 新版的 DOS 也使用这种方法处理文本文件。UNIX 使用这种方法处理所有的文件。

> C 语言中

- 在 C 语言中，用 getchar() 读取文件检测到文件结尾时将返回一个特殊的值， 即 EOF（end of file的缩写, 定义在 stdio.h, 【#define EOF -1】）。scanf() 函数检测到文件结尾时也返回 EOF

- 可以使用 【while ((ch = getchar()) != EOF)】 检查是否到文件结尾，在大多数 UNIX 和 Linux 系统中，在一行开始处按下 Ctrl+D 会传输文件结尾信号。许多微型计算机系统都把一行开始处的 Ctrl+Z 识别为文件结尾信号
  
```c
#include <stdio.h>
int main(void)
{
    int ch;
    while ((ch = getchar()) != EOF)
    putchar(ch);
    return 0;
}
// UNIX 和 Linux 键入 Ctrl+D 模拟文件的结束
// PC 采用 Ctrl+Z
```

---
## 5. 重定向和文件

- 输入和输出涉及函数、数据和设备

* 程序可以通过两种方式使用文件: 
  - 显式使用特定的函数打开文件、关闭文件、读取文件、写入文件
  - 设计能与键盘和屏幕互动的程序，通过不同的渠道重定向输入至文件和从文件输出

---
### 5.1 UNIX, Linux 和 DOS 重定向

- UNIX（运行命令行模式时）、Linux（ditto）和 Window 命令行提示（模仿旧式 DOS 命令行环境）都能重定向输入、输出

- 重定向输入让程序使用文件而不是键盘来输入，重定向输出让程序输出至文件而不是屏幕。

> 重定向输入

- 假设编译该程序并在某系统中运行

```c
/*  echo.exe  */
#include <stdio.h>
int main(void)
{
    int ch;
    while ((ch = getchar()) != EOF)
    putchar(ch);
    return 0;
}
```

- 程序获取从键盘输入的输入, 现在用该程序处理名为 words 的文本文件, 重定向操作

```
   $ echo < words
```

- \< 符号是 UNIX 和 DOS/Windows 的重定向运算符, 该运算符使 words 文件与 stdin 流相关联, 将文件中的内容导入到 echo 程序中

> 重定向输出

- \> 符号是第二个重定向运算符, 【echo > newFile】 表示将程序 echo 的输出重定向到该文件中

- 重定向把 stdout 从显示设备定向赋给 newFile 文件(通常会擦除该文件的内容然后替换新的内容)

> 组合重定向

```c
    $ echo < words > newFile
    或 echo > newFile < words
    // 表示制作一份 words 的副本到 newFile
```

---
### 5.2 重定向运算符的使用原则

- 命令与重定向符的顺序无关, 且输入与输出的文件名不能相同

- 重定向运算符连接一个可执行程序（包括标准操作系统命令）和一个数据文件，不能用于连接一个数据文件和另一个数据文件，也不能用于连接一个程序和另一个程序。

- 使用重定向运算符不能读取多个文件的输入，也不能把输出定向至多个文件。

- 文件名和运算符之间的空格不是必须的, 和特殊的系统有关

- UNIX, Linux 或 Windows/DOS 有【>>】运算符, 表示把数据添加到现有文件的末尾, 【 | 】运算符能把一个文件的输出连接到另一个文件的输入

---