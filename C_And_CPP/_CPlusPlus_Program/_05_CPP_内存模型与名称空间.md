# CPP 内存模型与名称空间

- 单独编译
- 存储持续性, 作用域和链接性
- 定位(placement) new 运算符
- 名称空间

---
- [CPP 内存模型与名称空间](#cpp-内存模型与名称空间)
	- [1. 单独编译](#1-单独编译)
	- [2. 存储持续性, 作用域, 链接性](#2-存储持续性-作用域-链接性)
		- [2.1 作用域与链接](#21-作用域与链接)
		- [2.2 自动存储持续性](#22-自动存储持续性)
		- [2.3 register 寄存器变量](#23-register-寄存器变量)
		- [2.4 静态持续变量](#24-静态持续变量)
		- [2.5 外部链接与引用声明 extern](#25-外部链接与引用声明-extern)
		- [2.6 说明符与限定符](#26-说明符与限定符)
		- [2.7 函数与链接性](#27-函数与链接性)
		- [2.8 语言链接性](#28-语言链接性)
		- [2.9  存储方案与动态分配](#29--存储方案与动态分配)
		- [2.10 new 定位符](#210-new-定位符)
	- [3. 名称空间](#3-名称空间)
		- [3.1 using 声明与编译指令](#31-using-声明与编译指令)
		- [3.2 名称空间的一些特性](#32-名称空间的一些特性)
		- [3.3 未命名名称空间](#33-未命名名称空间)
		- [3.4 名称空间的一般使用规则](#34-名称空间的一般使用规则)

---
## 1. 单独编译

- C++ 也允许程序员将组件函数放在独立的文件中, 可以单独编译这些文件，然后将它们链接成可执行的程序

- 提供了 #include 来处理这种情况。与其将结构声明加入到每一个文件中，不如将其放在头文件中，然后在每一个源代码文件中包含该头文件

* 可以将原来的程序分成三部分
  - 头文件：包含结构声明和使用这些结构的函数的原型。
  - 源代码文件：包含与结构有关的函数的代码。
  - 源代码文件：包含调用与结构相关的函数的代码。

> 头文件中常包含的内容

- 函数原型。
- 使用 #define 或 const 定义的符号常量。
- 结构声明。
- 类声明。
- 模板声明。
- 内联函数。

> 头文件包含

- include "head.h" 表示编译器首先查找当前工作目录或源代码目录
- include \<head.h> 表示编译器在存储标准头文件的主机系统的文件系统中查找

- 在 IDE 中，不要将头文件加入到项目列表中，也不要在源代码文件中使用 #include 来包含其他源代码文件。

> 防止包含多个头文件

- 使用预处理指令避免同一个文件中多次包含同一个头文件

```c++
#ifndef HEAD_H_
#define HEAD_H_
	// 头文件内容
	// 保证仅有一次头文件包含生效
#endif
```

---
## 2. 存储持续性, 作用域, 链接性

- C++ 使用三种（在 C++11 中是四种）不同的方案来存储数据

> 自动存储持续性

- 自动存储持续性：在函数定义中声明的变量（包括函数参数）的存储持续性为自动的。
  
- 它们在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，它们使用的内存被释放。

- C++ 有两种存储持续性为自动的变量。

> 静态存储持续性

- 静态存储持续性：在函数定义外定义的变量和使用关键字 static 定义的变量的存储持续性都为静态。
  
- 它们在程序整个运行过程中都存在。
  
- C++ 有 3 种存储持续性为静态的变量。

> 线程存储持续性 (C++11)

- 线程存储持续性（C++11）：当前，多核处理器很常见，这些 CPU 可同时处理多个执行任务。
  
- 这让程序能够将计算放在可并行处理的不同线程中。
  
- 如果变量是使用关键字 thread_local 声明的，则其生命周期与所属的线程一样长

> 动态存储持续性

- 动态存储持续性：用 new 运算符分配的内存将一直存在，直到使用 delete 运算符将其释放或程序结束为止。
  
- 这种内存的存储持续性为动态，有时被称为自由存储（free store）或堆（heap）。

---
### 2.1 作用域与链接

- 作用域（scope）描述了名称在文件（翻译单元）的多大范围内可见

- 函数中定义的变量可在该函数中使用，但不能在其他函数中使用；而在文件中的函数定义之前定义的变量则可在所有函数中使用。

- 链接性（linkage）描述了名称如何在不同单元间共享

- 链接性为外部的名称可在文件间共享，链接性为内部的名称只能由一个文件中的函数共享。
  
- 自动变量的名称没有链接性，因为它们不能共享。

- 不同的 C++ 存储方式是通过存储持续性、作用域和链接性来描述的

---
### 2.2 自动存储持续性

- 在 C++11 中，关键字 auto 用于自动类型推断, 旧版本中用于显式地指定变量为自动存储

```c++
int main(){
	auto ford = 1.5f; // 自动类型
}
```

> 自动变量和栈的工作

- 程序在运行时必须对自动变量进行管理, 程序会留出一段内存, 将其视为栈, 用以管理变量的增减

- 栈的默认长度取决于实现, 程序使用两个指针来跟踪栈, 分别是栈顶(下一个内存单元)与栈底(栈的开始位置)

- 当函数被调用时，其自动变量将被加入到栈中，栈顶指针指向变量后面的下一个可用的内存单元

- 函数结束时，栈顶指针被重置为函数被调用前的值，从而释放新变量使用的内存。

---
### 2.3 register 寄存器变量

- 关键字 register 最初是由 C 语言引入的，它建议编译器使用 CPU 寄存器来存储自动变量, 旨在提高访问变量的速度

- 在 C++11 之前的用法和 C 相同, 但在 C++11 中, 关键字 register 只能用于显式指出变量是自动类型, 与 C++ 旧版的 auto 相同, 一般是区别在内部使用的变量可能与外部变量相同

---
### 2.4 静态持续变量

- C++ 为静态存储持续性变量提供了 3 种链接性, 外部链接性(可在其他文件中访问), 内部链接性(只能在当前文件中访问), 无链接性(只能在当前函数或者代码块中访问)

- 编译器将分配固定的内存块来存储所有的静态变量，这些变量在整个程序执行期间一直存在

- 如果没有显式地初始化静态变量，编译器将把它设置为 0。在默认情况下，静态数组和结构将每个元素或成员的所有位都设置为 0

```c++
int global = 100; // 静态外部链接
static int one_file = 50;  // 静态内部链接
int main(void){
	static int count = 10;	// 静态无链接
	int t = 1;	// 自动类型
}
```

- 所有的静态持续变量都有下述初始化特征：未被初始化的静态变量的所有位都被设置为 0

> 静态变量初始化的过程

- 首先, 所有的静态变量都被零初始化, 而不管程序员是否显式地初始化它

- 然后, 若使用常量表达式初始化了变量, 且编译器仅根据文件内容（包括被包含的头文件）就可计算表达式，编译器将执行常量表达式初始化

- 如果没有足够的信息，变量将被动态初始化

```c++
#include<cmath>

int x;	// 零初始化
int y = 5;	// 常量初始化
int z = 5*5;  // 常量表达式初始化
const double PI = 4.0 * atan(1.0);	// 动态初始化
// PI 的初始化需要调用函数 atan, 并在该函数被链接且程序执行时
```

- C++11 新增 constexpr 创建常量表达式的方式

---
### 2.5 外部链接与引用声明 extern

- 链接性为外部的变量通常简称为外部变量(也叫全局变量)，它们的存储持续性为静态，作用域为整个文件, 一般在头文件中声明, 或 main() 前面

> 变量单定义规则

- 单定义规则（One Definition Rule，ODR），该规则指出，变量只能有一次定义, C++ 提供了两种声明方式

- 一种是定义声明（defining declaration）或简称为定义（definition），它给变量分配存储空间；

- 另一种是引用声明（referencing declaration）或简称为声明（declaration），它不给变量分配存储空间，因为它引用已有的变量。

```c++
// 引用声明使用关键字extern，且不进行初始化
double up;	// 定义声明
extern int blem; // 引用声明
extern char gr = 'r'; // 被初始化, 定义声明
```

> extern 引用声明的作用

- 如果要在多个文件中使用外部变量，只需在一个文件中包含该变量的定义（单定义规则）, 但在使用该变量的其他所有文件中，都必须使用关键字 extern 声明它

```c++
// file1
extern int cats = 20;	// 定义声明
int dogs = 22;
// file2 use file1
extern int dogs;  // 引用声明
// 无法访问 cats, 未引用声明
```

- 静态内部链接优先级高于外部链接变量(同名时)
  
---
### 2.6 说明符与限定符

- 存储说明符 auto(C++11之前), register, static, extern, thread_local(C++11), mutable(根据 const 来解释) 

> CV-限定符之 volatile

- const 表明，内存被初始化后，程序便不能再对它进行修改
  
- volatile 表明，即使程序代码没有对内存单元进行修改，其值也可能发生变化, 在调用 volatile 类型变量时, 必须每次从它的地址处访问值; 一般变量在调用时, 程序会将该值存储在寄存器中, 二次调用时直接读取寄存器而不是从原地址处访问值, 这是一种编译器的优化策略

- 如果变量在两次调用之间可能存在被其他程序或操作系统修改的风险, 需要将该变量声明为 volatile, 取消编译器的优化策略

> CV-限定符之 const

- 在 C++（但不是在 C 语言）中，const 限定符对默认存储类型稍有影响。在默认情况下全局变量的链接性为外部的，但 const 全局变量的链接性为内部的

- const 内部链接性还意味着，每个文件都有自己的一组常量，而不是所有文件共享一组常量

- 每个定义都是其所属文件私有的，这就是能够将常量定义放在头文件中的原因, 只要在两个源代码文件中包括同一个头文件，则它们将获得同一组常量

- 定义外部链接的常量

```c++
extern const int states = 50;	
```

> mutable

- mutable 指出，即使结构（或类）变量为 const，其某个成员也可以被修改

```c++
struct data{
	string Name;
	mutable int accesses;
};
const data veep = {"Book",0};
veep.Name = "book";  // not allowed
veep.accesses++;	// allowed
```

---
### 2.7 函数与链接性

- 默认情况下, 函数的链接性为外部的, 且所有函数的存储持续性为静态的

- 可以使用 static 将函数的链接性设置为内部的, 当包含的文件中存在同名的外部函数, 内部静态将覆盖外部函数

> C++ 在哪里查找函数

- 如果该文件中的函数原型指出该函数是静态的，则编译器将只在该文件中查找函数定义; 否则，编译器（包括链接程序）将在所有的程序文件中查找

- 如果找到两个定义，编译器将发出错误消息，因为每个外部函数只能有一个定义

- 如果在程序文件中没有找到，编译器将在库中搜索。这意味着如果定义了一个与库函数同名的函数，编译器将使用程序员定义的版本，而不是库函数

- 有些编译器 - 链接程序要求显式地指出要搜索哪些库。

---
### 2.8 语言链接性

- 链接程序要求每个不同的函数都有不同的符号名。在 C 语言中，一个名称只对应一个函数，因此这很容易实现。为满足内部需要，C 语言编译器可能将 spiff 这样的函数名翻译为 _spiff。这种方法被称为 C 语言链接性（C language linkage）

- C++ 中存在函数重载，同一个名称可能对应多个函数，必须将这些函数翻译为不同的符号名称。因此，C++ 编译器执行名称矫正或名称修饰，为重载函数生成不同的符号名称。例如，可能将 spiff（int）转换为 _spoff_i，而将 spiff（double，double）转换为 _spiff_d_d。这种方法被称为 C++ 语言链接（C++ language linkage）。

> 可以使用函数原型指定要使用的语言链接方式

```c++
extern "C" void spiff(int);		// use C protocol
extern void spoff(int); 		// use C++ protocol
extern "C++" void spaff(int);   // use C++ protocol
```

---
### 2.9  存储方案与动态分配

- 通常，编译器使用三块独立的内存：一块用于静态变量（可能再细分），一块用于自动变量，另外一块用于动态存储。

- 动态内存的分配使用 new 声明分配, 返回内存的首地址, 使用 delete 释放内存

- 存储方案概念不适用于动态内存，但适用于用来跟踪动态内存的自动和静态指针变量

```c++
int * pInt = new int(10);
struct St * pS = new St{...};
int * pArr = new int [4]{1,2,3,4};
```

- new 可能找不到请求的内存量时, 将引发异常 std::bad_alloc

- delete 释放内存意味着 new 申请的内存可以被程序回收使用, 但数据不会被立即回收, 继续使用该内存时, 结果是未定义的, 因此可以使用 delete 释放内存后, 将指针置空

> new 运算符, 函数和替换函数

- 运算符 new 与 new[] 的实质调用函数

```c++
void * operator new(std ::size_t);
void * operator new [] (std::size_t);

int * Pi = new int;  //转换成
int * Pi = new(sizeof(int));
```

- 运算符 delete 与 delete[] 

```C++
void operator delete(void *);
void operator delete [] (void *);

int * pa = new int[40];
delete [] pa;  // 转换成
delete(40*sizeof(int));
pa = NULL;
```

---
### 2.10 new 定位符

- 通常，new 负责在堆（heap）中找到一个足以能够满足要求的内存块。new 运算符还有另一种变体，被称为定位（placement）new 运算符，它能够指定要使用的位置

- 首先需要包含头文件 new，该头文件为 new 运算符用于提供了所需地址的参数

```c++
#include <new>
struct chaff
{
	char dross[20];
	int slag;
};
char buffer1[50];
char buffer2[500];
int main(void){
	chaff *p1,*p2;
	int *p3,*p4;
	// first, the regular forms of new
	p1 = new chaff;			// place structure in heap
	p3 = new int[20];		// place int array in heap
	// now, the two forms of placement new
	p2 = new (buffer1) chaff;	// place structure in buffer1
	p4 = new (buffer2) int[20]; // place int array in buffer2
}
```

> 定位 new 与常规 new 的区别

- 定位 new 使用指定的地址作为申请空间的起始点，p2 和 buffer1 指向同一个地址；常规 new 在堆空间中查找合适大小的内存空间，存在失败的可能

- 定位 new 不跟踪哪些内存单元已被使用，也不查找未使用的内存块；常规 new 查找一个新的内存块

- 定位 new 使用 buffer1 指定的内存是静态内存，常规 new 在堆中寻找未使用的内存，delete 只能释放常规 new 指向的内存区域，不能释放定位 new 指向的静态区域

- 如果 buffer1 是常规 new 分配的内存，使用定位 new 将 buffer1 用于定位分配时，可以使用 delete 释放 buffer1

> 定位 new 的其他形式

- 就像常规 new 调用一个接收一个参数的 new() 函数一样，标准定位 new 调用一个接收两个参数的 new() 函数

```c++
int * p1 = new int;  		  	==>   new(sizeof(int))
int * p2 = new(buffer) int;   	==>   new(sizeof(int),buffer)
int * p3 = new(buffer) int[40]; ==>   new(40*sizeof(int),buffer)
```

---
## 3. 名称空间

- 通过定义一种新的声明区域来创建命名的名称空间，这样做的目的之一是提供一个声明名称的区域。
  
- 一个名称空间中的名称不会与另外一个名称空间的相同名称发生冲突，同时允许程序的其他部分使用该名称空间中声明的东西

- 名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中

- 在名称空间内声明的名称默认的链接性为外部，除了用户定义，在全局存在全局名称空间（global namespace）

```c++
#include<iostream>
//...
namespace name1{
	int name1_a;
	//...
}
namespace name2{
	namespace name2_2{ // 嵌套
		int b = name1::name1_a;
	}
}
using namespace name2::name2_2;
```

---
### 3.1 using 声明与编译指令

- C++ 提供了两种机制（using 声明和 using 编译指令）来简化对名称空间中名称的使用。

- 使用 using 编译指令，使整个名称空间可用

- 使用 using 声明，使特定的标识符可用

```c++
namespace Space{
	int num;
	void fetch(){
		//...
	}
}
char fetch;
int main(void){
	// 1. using 声明
	using Space::fetch;
	fetch(); 

	// 2. using 编译指令
	using namespace	Space;
	num = 10;
	fetch();

	// 3. 使用全局名称空间
	::fetch = (char)num;

	// 4. 直接使用名称空间
	cout << Space::num << endl;
}
```

> 注意

- 假设名称空间和声明区域定义了相同的名称。如果试图使用 using 声明将名称空间的名称导入该声明区域，则这两个名称会发生冲突，从而出错。

- 如果使用 using 编译指令将该名称空间的名称导入该声明区域，则局部版本将隐藏名称空间版本(不参考声明先后位置)。

---
### 3.2 名称空间的一些特性

- 可以在名称空间中使用 using 编译指令和 using 声明, 当包含该空间时, 其链接的其他空间的成员也可以访问

```c++
namespace Nums{
	int num1;
	int num2; 
}
namespace S{
	using std::cout
	using namespace Nums;
}
int main(){
	using namespace S;
	cout << Nums::num1;  // cout 包含在 S 中
}
```

> 名称空间别名

```c++
namespace My_Name_is_so_Long{
	//...
}
// 别名
namespace Ms = My_Name_is_so_Long;
// 使用 Ms 代替 My_Name_is_so_Long
```

---
### 3.3 未命名名称空间

- 可以通过省略名称空间的名称来创建未命名的名称空间, 在该名称空间中声明的名称的潜在作用域为：从声明点到该声明区域末尾

- 使用该名称空间中的名称。这提供了链接性为内部的静态变量的替代品

```c++
namespace{ // 无法在外部访问
	int num1; // 相当于 static int num1
	int num2; // 相当于 static int num2
}
int main(){
	num1 = 10;
	cout << num2;
}
```

---
### 3.4 名称空间的一般使用规则

- 使用在已命名的名称空间中声明的变量，而不是使用外部全局变量

- 使用在已命名的名称空间中声明的变量，而不是使用静态全局变量

- 如果开发了一个函数库或类库，将其放在一个名称空间中

- 仅将编译指令 using 作为一种将旧代码转换为使用名称空间的权宜之计。

- 不建议在头文件中使用 using 编译指令 (但应该在 include 指令之后使用 using)

- 导入名称时，首选使用作用域解析运算符 (spacename::member) 或 using 声明的方法

- 对于 using 声明，首选将其作用域设置为局部而不是全局 (在局部中声明)

---