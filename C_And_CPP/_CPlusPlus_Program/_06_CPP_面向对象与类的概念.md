# CPP 面向对象与类的概念


---
- [CPP 面向对象与类的概念](#cpp-面向对象与类的概念)
	- [1. 抽象与类](#1-抽象与类)
		- [1.1 类型的基本要素](#11-类型的基本要素)
		- [1.2 C++ 类](#12-c-类)
		- [1.3 类成员的访问控制](#13-类成员的访问控制)
		- [1.4 成员方法的实现](#14-成员方法的实现)
		- [1.5 类对象与成员访问](#15-类对象与成员访问)
	- [2. 构造函数与析构函数](#2-构造函数与析构函数)
		- [2.1 类构造函数声明与定义](#21-类构造函数声明与定义)
		- [2.2 析构函数](#22-析构函数)
	- [3. this 指针](#3-this-指针)

---
## 1. 抽象与类

### 1.1 类型的基本要素

* 一个基本类型的声明与创建, 完成了基本的三项工作:
  - 决定数据对象需要的内存数量
  - 决定如何解释内存中的位（long 和 float 在内存中占用的位数相同，但将它们转换为数值的方法不同）
  - 决定可使用数据对象执行的操作或方法

- 在 C++ 中定义用户自定义的类型时，必须自己提供这些有关操作的信息

---
### 1.2 C++ 类

- 类是一种将抽象转换为用户定义类型的 C++ 工具，它将数据表示和操纵数据的方法组合成一个整洁的包

> 类规范由两部分组成

- 类声明：以数据成员的方式描述数据部分，以成员函数的方式描述公有接口
  
- 类方法定义：描述如何实现类成员函数

- 类声明提供了类的蓝图，方法定义提供了细节

> 接口的基本概念

- 接口是一个共享框架，供两个系统或模块之间的交互时使用

- 对于类，我们说公共接口。公众（public）是使用类的程序，交互系统由类对象组成，而接口由编写类的人提供的方法组成

- 要使用某个类，必须了解其公共接口；要编写类，必须创建其公共接口。

> 类的声明示例

```c++
class MclassA{
	private: // 默认行为， 可省略
		// 私有成员 code
	public:
		// 公有成员 code
		MclassA(/* args */); // 构造函数
		~MclassA(); 		 // 析构函数
};

MclassA::MclassA(/* args */){
	// 定义构造函数
}
MclassA::~MclassA(){
	// 定义析构函数
}
```

---
### 1.3 类成员的访问控制

- 关键字 private 标识只能通过公共成员访问的类成员（数据隐藏）

- 关键字 public 标识组成类的公共接口的类成员（抽象）
  
- protected 提供了类继承子类访问父类成员的控制权限（类继承）

> 类与结构

- 结构的默认访问类型是 public，而类为 private。C++ 通常使用类来实现类描述，而把结构限制为只表示纯粹的数据对象

---
### 1.4 成员方法的实现

- 为那些由类声明中的原型表示的成员函数提供代码

```c++
class Mc{
	int p_num = 10
	public:
		void Func(void); // 抽象函数原型
};
void Mc::Func(void){	// 定义 Mc 的公有函数
	std::cout << "Func: "<< p_num << endl; // 在公有方法中调用内部成员
}
```

> 内联方法

- 其定义位于类声明中的函数都将自动成为内联函数, 类声明常将短小的成员函数作为内联函数

- 类内联方法可以直接在 private 块定义, 也可以定义(inline 修饰)在类声明之后

```c++
class Mc{
	private:
		void set_pF();  // 可以直接实现, 也可外部实现, 但访问限制不变
	public:
		//...
};
inline void Mc::set_pF(){
	// 使用内联函数定义
}
```
 
---
### 1.5 类对象与成员访问

```c++
#include <iostream>
class Mc{
	public:
		int num;
		void Func();
};
void Mc::Func(){
	num = 10;
	std::cout << num << std::endl;
}
int main(){
	Mc mclass;  // 类对象
	std::cout << mclass.num << std::endl;  // 为初始化, 直接访问其结果是未定义
	mclass.Func();  // 调用 Func, 并初始化 num
	std::cout << mclass.num << std::endl;  // num = 10
	return 0;    
}
```

- 类声明中的成员变量为初始化时, 其值是未定义的

- 类对象的声明方式与结构相似

---
## 2. 构造函数与析构函数

- C++ 的目标之一是让使用类对象就像使用标准类型一样, 虽然可以像结构那样声明类对象, 但不能使用初始化结构那样初始化类的成员

```c++
struct S{
	int num ;
};
class C{
	public:
	int num;
};
S s = {1};
C c = {1}; // error
```

- 可以使用类构造函数在创建类对象的时候对其内部成员进行初始化

---
### 2.1 类构造函数声明与定义

- 构造函数没有返回值, 且参数列表名称不能与函数内部的成员名称相同

- 构造函数可以重载

- 每一个类声明时, 都有一个隐式的无参构造, 但一旦显式声明了构造函数, 默认的构造将失效 (只能显式方式声明并定义)

- 在设计类时，通常应提供对所有类成员做隐式初始化的默认构造函数。

```c++
class Mc{
private:
	int m_num;
public:
	Mc(int);	// 声明构造原型
};
Mc::Mc(int num){  // 定义构造 
	m_num = num;
}
int main(){
	Mc m = Mc(10);	//  使用构造创建类对象
	Mc m(10);  // 等价

	Mc m(); // error , 未定义无参构造
}

// 当显式定义无参构造时
Mc m();  // 表示 m() 返回一个 mc 对象的函数, 并不是创建 m 对象
// 应去掉 ()
Mc m = Mc();
Mc m;	//等价
```

---
### 2.2 析构函数

- 用构造函数创建对象后，程序负责跟踪该对象，直到其过期为止。

- 对象过期时, 程序将自动调用类的析构函数, 用于完成清理工作

- 可以在构造函数中使用 new 来分配内存, 在析构函数中 delete 来释放内存

- 析构函数默认提供, 无参且可以用户定义

```c++
class Mc{
	public:
	~Mc();
};
Mc::~Mc(){
	//...
}
```

> 何时调用析构函数

- 如果创建的是静态存储类对象，则其析构函数将在程序结束时自动被调用

- 如果创建的是自动存储类对象，则其析构函数将在程序执行完代码块时（该对象是在其中定义的）自动被调用

---
## 3. this 指针

- this 指针指向用来调用成员函数的对象（this 被作为隐藏参数传递给方法)

- 通过 this 去显式调用类成员, 在成员方法内没有同名类型声明时(指与类成员不同名), 可以直接使用成员名称(隐式实现 this 调用)

- 通过 this 调用成员用来区分方法内的同名标识, this 本质是类对象的地址, 每一个成员函数域内都包含一个 this 指针

```c++
class Mc{
	int num;
	public:
	void Fun(int num);
};

void Mc::Fun(int num){
	this->num = num;	// 通过 this 去显式调用类成员
}
```



